{"ast":null,"code":"import _slicedToArray from \"/Users/alex/Downloads/ziina-take-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar _s = $RefreshSig$();\nimport { useCallback, useEffect, useState } from \"react\";\nexport var useDrag = function useDrag(_ref) {\n  _s();\n  var ref = _ref.ref,\n    id = _ref.id,\n    callBack = _ref.callBack;\n  var Xs = [400, 483, 313, 245, 480]; // initial x coordinates of the draggable elements\n  var Ys = [476, 350, 276, 435, 211]; // initial y coordinates of the draggable elements\n  var initialX = Xs[id];\n  var initialY = Ys[id];\n  var _useState = useState(),\n    _useState2 = _slicedToArray(_useState, 2),\n    dragInfo = _useState2[0],\n    setDragInfo = _useState2[1];\n  var _useState3 = useState({\n      x: initialX,\n      y: initialY\n    }),\n    _useState4 = _slicedToArray(_useState3, 2),\n    finalPosition = _useState4[0],\n    setFinalPosition = _useState4[1];\n  var _useState5 = useState(false),\n    _useState6 = _slicedToArray(_useState5, 2),\n    isDragging = _useState6[0],\n    setIsDragging = _useState6[1];\n  var overlappingArea = 0;\n  var handleMouseUp = function handleMouseUp(evt) {\n    evt.preventDefault();\n    setIsDragging(false); // indicates that the user has stopped dragging the element\n  };\n\n  var handleMouseDown = function handleMouseDown(evt) {\n    evt.preventDefault();\n    var clientX = evt.clientX,\n      clientY = evt.clientY;\n    var draggableElement = ref.current; // get the current element that is being dragged\n\n    if (!draggableElement) {\n      return;\n    }\n    var _draggableElement$get = draggableElement.getBoundingClientRect(),\n      top = _draggableElement$get.top,\n      left = _draggableElement$get.left,\n      width = _draggableElement$get.width,\n      height = _draggableElement$get.height;\n    setIsDragging(true); // indicates that the user has started dragging the element\n    setDragInfo({\n      startX: clientX,\n      startY: clientY,\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    });\n  };\n  var handleMouseMove = useCallback(function (evt) {\n    var draggableElement = ref.current; // get the current element that is being dragged\n\n    if (!isDragging || !draggableElement) return; // if the user is not dragging the element, do nothing\n\n    evt.preventDefault();\n    var clientX = evt.clientX,\n      clientY = evt.clientY; // get the current position of the mouse\n\n    var position = {\n      x: dragInfo.startX - clientX,\n      y: dragInfo.startY - clientY\n    }; // calculate the distance between the current position of the mouse and the initial position of the mouse\n\n    var top = dragInfo.top,\n      left = dragInfo.left,\n      width = dragInfo.width,\n      height = dragInfo.height;\n    var current_coords = draggableElement.getBoundingClientRect();\n    //console.log(draggableElement.getBoundingClientRect())\n    var redBoxCoords = document.getElementById('red-box').getBoundingClientRect();\n    // check if the current position of the draggable element overlaps with the red box\n    if (current_coords.left < redBoxCoords.right && current_coords.right > redBoxCoords.left && current_coords.top < redBoxCoords.bottom && current_coords.bottom > redBoxCoords.top) {\n      // calculate the overlapping area\n      overlappingArea = Math.max(0, Math.min(current_coords.right, redBoxCoords.right) - Math.max(current_coords.left, redBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, redBoxCoords.bottom) - Math.max(current_coords.top, redBoxCoords.top));\n      // if the current element overlaps with another draggable element, reduce the overlapping area by the area of the other draggable element\n      var blue_boxes = document.getElementsByClassName(\"draggable\");\n      for (var i = 0; i < blue_boxes.length; i++) {\n        if (blue_boxes[i].id !== draggableElement.id) {\n          var blueBoxCoords = blue_boxes[i].getBoundingClientRect();\n          if (current_coords.left < blueBoxCoords.right && current_coords.right > blueBoxCoords.left && current_coords.top < blueBoxCoords.bottom && current_coords.bottom > blueBoxCoords.top) {\n            overlappingArea -= Math.max(0, Math.min(current_coords.right, blueBoxCoords.right) - Math.max(current_coords.left, blueBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, blueBoxCoords.bottom) - Math.max(current_coords.top, blueBoxCoords.top));\n            console.log(overlappingArea);\n          }\n        }\n      }\n    } else {\n      // if it is not, set the overlapping area to 0\n      overlappingArea = 0;\n    }\n    callBack(overlappingArea); // call the callback function to update the overlapping area of the draggable element\n    setFinalPosition({\n      x: left - position.x,\n      y: top - position.y\n    }); // update the final position of the draggable element\n  }, [isDragging, dragInfo, ref]);\n  useEffect(function () {\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n    return function () {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [handleMouseMove]);\n  return {\n    position: finalPosition,\n    handleMouseDown: handleMouseDown\n  };\n};\n_s(useDrag, \"Yr7awxu5AALMG3ommDYpy4hAr7M=\");","map":{"version":3,"names":["useCallback","useEffect","useState","useDrag","_ref","_s","ref","id","callBack","Xs","Ys","initialX","initialY","_useState","_useState2","_slicedToArray","dragInfo","setDragInfo","_useState3","x","y","_useState4","finalPosition","setFinalPosition","_useState5","_useState6","isDragging","setIsDragging","overlappingArea","handleMouseUp","evt","preventDefault","handleMouseDown","clientX","clientY","draggableElement","current","_draggableElement$get","getBoundingClientRect","top","left","width","height","startX","startY","handleMouseMove","position","current_coords","redBoxCoords","document","getElementById","right","bottom","Math","max","min","blue_boxes","getElementsByClassName","i","length","blueBoxCoords","console","log","addEventListener","removeEventListener"],"sources":["/Users/alex/Downloads/ziina-take-home/src/useDrag.js"],"sourcesContent":["import { useCallback, useEffect, useState } from \"react\";\n\nexport const useDrag = ({ ref, id, callBack }) => {\n  const Xs = [400, 483, 313, 245, 480]; // initial x coordinates of the draggable elements\n  const Ys = [476, 350, 276, 435, 211]; // initial y coordinates of the draggable elements\n  const initialX = Xs[id];\n  const initialY = Ys[id];\n  const [dragInfo, setDragInfo] = useState();\n  const [finalPosition, setFinalPosition] = useState({\n    x: initialX,\n    y: initialY,\n  });\n  const [isDragging, setIsDragging] = useState(false);\n  let overlappingArea = 0;\n\n  const handleMouseUp = (evt) => {\n    evt.preventDefault();\n\n    setIsDragging(false); // indicates that the user has stopped dragging the element\n  };\n\n  const handleMouseDown = (evt) => {\n    evt.preventDefault();\n\n    const { clientX, clientY } = evt;\n    const { current: draggableElement } = ref; // get the current element that is being dragged\n\n    if (!draggableElement) {\n      return;\n    }\n\n    const {\n      top,\n      left,\n      width,\n      height\n    } = draggableElement.getBoundingClientRect();\n\n    setIsDragging(true); // indicates that the user has started dragging the element\n    setDragInfo({\n      startX: clientX,\n      startY: clientY,\n      top,\n      left,\n      width,\n      height\n    });\n\n  };\n\n  const handleMouseMove = useCallback(\n    (evt) => {\n      const { current: draggableElement } = ref; // get the current element that is being dragged\n\n      if (!isDragging || !draggableElement) return; // if the user is not dragging the element, do nothing\n\n      evt.preventDefault();\n\n      const { clientX, clientY } = evt; // get the current position of the mouse\n\n      const position = {\n        x: dragInfo.startX - clientX,\n        y: dragInfo.startY - clientY\n      }; // calculate the distance between the current position of the mouse and the initial position of the mouse\n\n      const { top, left, width, height } = dragInfo;\n\n      const current_coords = draggableElement.getBoundingClientRect();\n      //console.log(draggableElement.getBoundingClientRect())\n      const redBoxCoords = document.getElementById('red-box').getBoundingClientRect();\n      // check if the current position of the draggable element overlaps with the red box\n      if (current_coords.left < redBoxCoords.right && current_coords.right > redBoxCoords.left && current_coords.top < redBoxCoords.bottom && current_coords.bottom > redBoxCoords.top) {\n        // calculate the overlapping area\n        overlappingArea = Math.max(0, Math.min(current_coords.right, redBoxCoords.right) - Math.max(current_coords.left, redBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, redBoxCoords.bottom) - Math.max(current_coords.top, redBoxCoords.top));\n        // if the current element overlaps with another draggable element, reduce the overlapping area by the area of the other draggable element\n        const blue_boxes = document.getElementsByClassName(\"draggable\");\n        for (let i = 0; i < blue_boxes.length; i++) {\n          if (blue_boxes[i].id !== draggableElement.id) {\n            const blueBoxCoords = blue_boxes[i].getBoundingClientRect();\n            if (current_coords.left < blueBoxCoords.right && current_coords.right > blueBoxCoords.left && current_coords.top < blueBoxCoords.bottom && current_coords.bottom > blueBoxCoords.top) {\n              overlappingArea -= Math.max(0, Math.min(current_coords.right, blueBoxCoords.right) - Math.max(current_coords.left, blueBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, blueBoxCoords.bottom) - Math.max(current_coords.top, blueBoxCoords.top));\n              console.log(overlappingArea)\n            }\n          }\n        }\n      } else {\n        // if it is not, set the overlapping area to 0\n        overlappingArea = 0;\n      }\n      callBack(overlappingArea); // call the callback function to update the overlapping area of the draggable element\n      setFinalPosition({ x: left - position.x, y: top - position.y }); // update the final position of the draggable element\n    },\n    [isDragging, dragInfo, ref]\n  );\n\n  useEffect(() => {\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [handleMouseMove]);\n\n  return {\n    position: finalPosition,\n    handleMouseDown,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}