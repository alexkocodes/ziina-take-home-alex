{"ast":null,"code":"import _slicedToArray from \"/Users/alex/Downloads/ziina-take-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar _s = $RefreshSig$();\nimport { useCallback, useEffect, useState } from \"react\";\nexport var useDrag = function useDrag(_ref) {\n  _s();\n  var ref = _ref.ref,\n    id = _ref.id,\n    callBack = _ref.callBack;\n  var Xs = [400, 483, 313, 245, 480]; // initial x coordinates of the draggable elements\n  var Ys = [476, 350, 276, 435, 211]; // initial y coordinates of the draggable elements\n  var initialX = Xs[id];\n  var initialY = Ys[id];\n  var _useState = useState(),\n    _useState2 = _slicedToArray(_useState, 2),\n    dragInfo = _useState2[0],\n    setDragInfo = _useState2[1];\n  var _useState3 = useState({\n      x: initialX,\n      y: initialY\n    }),\n    _useState4 = _slicedToArray(_useState3, 2),\n    finalPosition = _useState4[0],\n    setFinalPosition = _useState4[1];\n  var _useState5 = useState(false),\n    _useState6 = _slicedToArray(_useState5, 2),\n    isDragging = _useState6[0],\n    setIsDragging = _useState6[1];\n  var overlappingArea = 0;\n  var handleMouseUp = function handleMouseUp(evt) {\n    evt.preventDefault();\n    setIsDragging(false); // indicates that the user has stopped dragging the element\n  };\n\n  var handleMouseDown = function handleMouseDown(evt) {\n    evt.preventDefault();\n    var clientX = evt.clientX,\n      clientY = evt.clientY;\n    var draggableElement = ref.current; // get the current element that is being dragged\n\n    if (!draggableElement) {\n      return;\n    }\n    var _draggableElement$get = draggableElement.getBoundingClientRect(),\n      top = _draggableElement$get.top,\n      left = _draggableElement$get.left,\n      width = _draggableElement$get.width,\n      height = _draggableElement$get.height;\n    setIsDragging(true); // indicates that the user has started dragging the element\n    setDragInfo({\n      startX: clientX,\n      startY: clientY,\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    });\n  };\n  var handleMouseMove = useCallback(function (evt) {\n    var draggableElement = ref.current; // get the current element that is being dragged\n\n    if (!isDragging || !draggableElement) return; // if the user is not dragging the element, do nothing\n\n    evt.preventDefault();\n    var clientX = evt.clientX,\n      clientY = evt.clientY; // get the current position of the mouse\n\n    var position = {\n      x: dragInfo.startX - clientX,\n      y: dragInfo.startY - clientY\n    }; // calculate the distance between the current position of the mouse and the initial position of the mouse\n\n    var top = dragInfo.top,\n      left = dragInfo.left,\n      width = dragInfo.width,\n      height = dragInfo.height;\n    var current_coords = draggableElement.getBoundingClientRect();\n    //console.log(draggableElement.getBoundingClientRect())\n    var redBoxCoords = document.getElementById('red-box').getBoundingClientRect();\n    // check if the current position of the draggable element overlaps with the red box\n    if (current_coords.left < redBoxCoords.right && current_coords.right > redBoxCoords.left && current_coords.top < redBoxCoords.bottom && current_coords.bottom > redBoxCoords.top) {\n      // // calculate the overlapping area\n      // overlappingArea = Math.max(0, Math.min(current_coords.right, redBoxCoords.right) - Math.max(current_coords.left, redBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, redBoxCoords.bottom) - Math.max(current_coords.top, redBoxCoords.top));\n      // // if the current element overlaps with another draggable element, reduce the overlapping area by the area of the other draggable element, and break the loop when there is overlapping to prevent double counting\n      // const blue_boxes = document.getElementsByClassName(\"draggable\");\n      // for (let i = 0; i < blue_boxes.length; i++) {\n      //   if (blue_boxes[i].id !== draggableElement.id) {\n      //     const blueBoxCoords = blue_boxes[i].getBoundingClientRect();\n      //     if (current_coords.left < blueBoxCoords.right && current_coords.right > blueBoxCoords.left && current_coords.top < blueBoxCoords.bottom && current_coords.bottom > blueBoxCoords.top) {\n      //       overlappingArea -= Math.max(0, Math.min(current_coords.right, blueBoxCoords.right) - Math.max(current_coords.left, blueBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, blueBoxCoords.bottom) - Math.max(current_coords.top, blueBoxCoords.top));\n      //       break;\n      //     }\n      //   }\n      // }\n      // use a sweep line algorithm to find the total coverage of all blue boxes that are within the red box\n      var blue_boxes = document.getElementsByClassName(\"draggable\");\n      var blueBoxCoords = [];\n      for (var i = 0; i < blue_boxes.length; i++) {\n        if (blue_boxes[i].id !== draggableElement.id) {\n          blueBoxCoords.push(blue_boxes[i].getBoundingClientRect());\n        }\n      }\n      blueBoxCoords.sort(function (a, b) {\n        return a.left - b.left;\n      });\n      var sweepLine = [];\n      var totalCoverage = 0;\n      for (var _i = 0; _i < blueBoxCoords.length; _i++) {\n        if (blueBoxCoords[_i].left < redBoxCoords.right && blueBoxCoords[_i].right > redBoxCoords.left) {\n          if (sweepLine.length === 0) {\n            sweepLine.push(blueBoxCoords[_i]);\n          } else {\n            if (blueBoxCoords[_i].top < sweepLine[0].bottom) {\n              if (blueBoxCoords[_i].bottom > sweepLine[0].bottom) {\n                sweepLine.push(blueBoxCoords[_i]);\n                sweepLine.sort(function (a, b) {\n                  return a.bottom - b.bottom;\n                });\n              }\n            } else {\n              totalCoverage += sweepLine[0].right - sweepLine[0].left;\n              sweepLine.shift();\n              _i--;\n            }\n          }\n        }\n      }\n      if (sweepLine.length > 0) {\n        totalCoverage += sweepLine[0].right - sweepLine[0].left;\n      }\n      overlappingArea = totalCoverage;\n    } else {\n      // if it is not, set the overlapping area to 0\n      overlappingArea = 0;\n    }\n    callBack(overlappingArea); // call the callback function to update the overlapping area of the draggable element\n    setFinalPosition({\n      x: left - position.x,\n      y: top - position.y\n    }); // update the final position of the draggable element\n  }, [isDragging, dragInfo, ref]);\n  useEffect(function () {\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n    return function () {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [handleMouseMove]);\n  return {\n    position: finalPosition,\n    handleMouseDown: handleMouseDown\n  };\n};\n_s(useDrag, \"Yr7awxu5AALMG3ommDYpy4hAr7M=\");","map":{"version":3,"names":["useCallback","useEffect","useState","useDrag","_ref","_s","ref","id","callBack","Xs","Ys","initialX","initialY","_useState","_useState2","_slicedToArray","dragInfo","setDragInfo","_useState3","x","y","_useState4","finalPosition","setFinalPosition","_useState5","_useState6","isDragging","setIsDragging","overlappingArea","handleMouseUp","evt","preventDefault","handleMouseDown","clientX","clientY","draggableElement","current","_draggableElement$get","getBoundingClientRect","top","left","width","height","startX","startY","handleMouseMove","position","current_coords","redBoxCoords","document","getElementById","right","bottom","blue_boxes","getElementsByClassName","blueBoxCoords","i","length","push","sort","a","b","sweepLine","totalCoverage","shift","addEventListener","removeEventListener"],"sources":["/Users/alex/Downloads/ziina-take-home/src/useDrag.js"],"sourcesContent":["import { useCallback, useEffect, useState } from \"react\";\n\nexport const useDrag = ({ ref, id, callBack }) => {\n  const Xs = [400, 483, 313, 245, 480]; // initial x coordinates of the draggable elements\n  const Ys = [476, 350, 276, 435, 211]; // initial y coordinates of the draggable elements\n  const initialX = Xs[id];\n  const initialY = Ys[id];\n  const [dragInfo, setDragInfo] = useState();\n  const [finalPosition, setFinalPosition] = useState({\n    x: initialX,\n    y: initialY,\n  });\n  const [isDragging, setIsDragging] = useState(false);\n  let overlappingArea = 0;\n\n  const handleMouseUp = (evt) => {\n    evt.preventDefault();\n\n    setIsDragging(false); // indicates that the user has stopped dragging the element\n  };\n\n  const handleMouseDown = (evt) => {\n    evt.preventDefault();\n\n    const { clientX, clientY } = evt;\n    const { current: draggableElement } = ref; // get the current element that is being dragged\n\n    if (!draggableElement) {\n      return;\n    }\n\n    const {\n      top,\n      left,\n      width,\n      height\n    } = draggableElement.getBoundingClientRect();\n\n    setIsDragging(true); // indicates that the user has started dragging the element\n    setDragInfo({\n      startX: clientX,\n      startY: clientY,\n      top,\n      left,\n      width,\n      height\n    });\n\n  };\n\n  const handleMouseMove = useCallback(\n    (evt) => {\n      const { current: draggableElement } = ref; // get the current element that is being dragged\n\n      if (!isDragging || !draggableElement) return; // if the user is not dragging the element, do nothing\n\n      evt.preventDefault();\n\n      const { clientX, clientY } = evt; // get the current position of the mouse\n\n      const position = {\n        x: dragInfo.startX - clientX,\n        y: dragInfo.startY - clientY\n      }; // calculate the distance between the current position of the mouse and the initial position of the mouse\n\n      const { top, left, width, height } = dragInfo;\n\n      const current_coords = draggableElement.getBoundingClientRect();\n      //console.log(draggableElement.getBoundingClientRect())\n      const redBoxCoords = document.getElementById('red-box').getBoundingClientRect();\n      // check if the current position of the draggable element overlaps with the red box\n      if (current_coords.left < redBoxCoords.right && current_coords.right > redBoxCoords.left && current_coords.top < redBoxCoords.bottom && current_coords.bottom > redBoxCoords.top) {\n        // // calculate the overlapping area\n        // overlappingArea = Math.max(0, Math.min(current_coords.right, redBoxCoords.right) - Math.max(current_coords.left, redBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, redBoxCoords.bottom) - Math.max(current_coords.top, redBoxCoords.top));\n        // // if the current element overlaps with another draggable element, reduce the overlapping area by the area of the other draggable element, and break the loop when there is overlapping to prevent double counting\n        // const blue_boxes = document.getElementsByClassName(\"draggable\");\n        // for (let i = 0; i < blue_boxes.length; i++) {\n        //   if (blue_boxes[i].id !== draggableElement.id) {\n        //     const blueBoxCoords = blue_boxes[i].getBoundingClientRect();\n        //     if (current_coords.left < blueBoxCoords.right && current_coords.right > blueBoxCoords.left && current_coords.top < blueBoxCoords.bottom && current_coords.bottom > blueBoxCoords.top) {\n        //       overlappingArea -= Math.max(0, Math.min(current_coords.right, blueBoxCoords.right) - Math.max(current_coords.left, blueBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, blueBoxCoords.bottom) - Math.max(current_coords.top, blueBoxCoords.top));\n        //       break;\n        //     }\n        //   }\n        // }\n        // use a sweep line algorithm to find the total coverage of all blue boxes that are within the red box\n        const blue_boxes = document.getElementsByClassName(\"draggable\");\n        const blueBoxCoords = [];\n        for (let i = 0; i < blue_boxes.length; i++) {\n          if (blue_boxes[i].id !== draggableElement.id) {\n            blueBoxCoords.push(blue_boxes[i].getBoundingClientRect());\n          }\n        }\n        blueBoxCoords.sort((a, b) => a.left - b.left);\n        let sweepLine = [];\n        let totalCoverage = 0;\n        for (let i = 0; i < blueBoxCoords.length; i++) {\n          if (blueBoxCoords[i].left < redBoxCoords.right && blueBoxCoords[i].right > redBoxCoords.left) {\n            if (sweepLine.length === 0) {\n              sweepLine.push(blueBoxCoords[i]);\n            } else {\n              if (blueBoxCoords[i].top < sweepLine[0].bottom) {\n                if (blueBoxCoords[i].bottom > sweepLine[0].bottom) {\n                  sweepLine.push(blueBoxCoords[i]);\n                  sweepLine.sort((a, b) => a.bottom - b.bottom);\n                }\n              } else {\n                totalCoverage += sweepLine[0].right - sweepLine[0].left;\n                sweepLine.shift();\n                i--;\n              }\n            }\n          }\n        }\n        if (sweepLine.length > 0) {\n          totalCoverage += sweepLine[0].right - sweepLine[0].left;\n        }\n        overlappingArea = totalCoverage;\n\n      } else {\n        // if it is not, set the overlapping area to 0\n        overlappingArea = 0;\n      }\n      callBack(overlappingArea); // call the callback function to update the overlapping area of the draggable element\n      setFinalPosition({ x: left - position.x, y: top - position.y }); // update the final position of the draggable element\n    },\n    [isDragging, dragInfo, ref]\n  );\n\n  useEffect(() => {\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [handleMouseMove]);\n\n  return {\n    position: finalPosition,\n    handleMouseDown,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}