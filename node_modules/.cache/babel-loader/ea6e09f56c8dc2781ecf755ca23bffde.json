{"ast":null,"code":"import _toConsumableArray from \"/Users/alex/Downloads/ziina-take-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/alex/Downloads/ziina-take-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar _s = $RefreshSig$();\nimport { useCallback, useEffect, useState } from \"react\";\n// create an array of 5 boxes that will be updated to store the coordinates of the overlapping area of each draggable element with the red box\nvar boxes_inside_red = {\n  0: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0\n  },\n  1: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0\n  },\n  2: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0\n  },\n  3: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0\n  },\n  4: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0\n  }\n};\nvar overlappingArea = 0;\nexport var useDrag = function useDrag(_ref) {\n  _s();\n  var ref = _ref.ref,\n    id = _ref.id,\n    callBack = _ref.callBack;\n  var Xs = [400, 483, 313, 245, 480]; // initial x coordinates of the draggable elements\n  var Ys = [476, 350, 276, 435, 211]; // initial y coordinates of the draggable elements\n  var initialX = Xs[id];\n  var initialY = Ys[id];\n  var _useState = useState(),\n    _useState2 = _slicedToArray(_useState, 2),\n    dragInfo = _useState2[0],\n    setDragInfo = _useState2[1];\n  var _useState3 = useState({\n      x: initialX,\n      y: initialY\n    }),\n    _useState4 = _slicedToArray(_useState3, 2),\n    finalPosition = _useState4[0],\n    setFinalPosition = _useState4[1];\n  var _useState5 = useState(false),\n    _useState6 = _slicedToArray(_useState5, 2),\n    isDragging = _useState6[0],\n    setIsDragging = _useState6[1];\n  var handleMouseUp = function handleMouseUp(evt) {\n    evt.preventDefault();\n    setIsDragging(false); // indicates that the user has stopped dragging the element\n  };\n\n  var handleMouseDown = function handleMouseDown(evt) {\n    evt.preventDefault();\n    var clientX = evt.clientX,\n      clientY = evt.clientY;\n    var draggableElement = ref.current; // get the current element that is being dragged\n\n    if (!draggableElement) {\n      return;\n    }\n    var _draggableElement$get = draggableElement.getBoundingClientRect(),\n      top = _draggableElement$get.top,\n      left = _draggableElement$get.left,\n      width = _draggableElement$get.width,\n      height = _draggableElement$get.height;\n    setIsDragging(true); // indicates that the user has started dragging the element\n    setDragInfo({\n      startX: clientX,\n      startY: clientY,\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    });\n  };\n  var handleMouseMove = useCallback(function (evt) {\n    var draggableElement = ref.current; // get the current element that is being dragged\n\n    if (!isDragging || !draggableElement) return; // if the user is not dragging the element, do nothing\n\n    evt.preventDefault();\n    var clientX = evt.clientX,\n      clientY = evt.clientY; // get the current position of the mouse\n\n    var position = {\n      x: dragInfo.startX - clientX,\n      y: dragInfo.startY - clientY\n    }; // calculate the distance between the current position of the mouse and the initial position of the mouse\n\n    var top = dragInfo.top,\n      left = dragInfo.left,\n      width = dragInfo.width,\n      height = dragInfo.height;\n    var current_coords = draggableElement.getBoundingClientRect();\n    //console.log(draggableElement.getBoundingClientRect())\n    var redBoxCoords = document.getElementById('red-box').getBoundingClientRect();\n    // check if the current position of the draggable element overlaps with the red box\n    if (current_coords.left < redBoxCoords.right && current_coords.right > redBoxCoords.left && current_coords.top < redBoxCoords.bottom && current_coords.bottom > redBoxCoords.top) {\n      // // calculate the overlapping area\n      // overlappingArea = Math.max(0, Math.min(current_coords.right, redBoxCoords.right) - Math.max(current_coords.left, redBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, redBoxCoords.bottom) - Math.max(current_coords.top, redBoxCoords.top));\n      // // if the current element overlaps with another draggable element, reduce the overlapping area by the area of the other draggable element, and break the loop when there is overlapping to prevent double counting\n      // const blue_boxes = document.getElementsByClassName(\"draggable\");\n      // for (let i = 0; i < blue_boxes.length; i++) {\n      //   if (blue_boxes[i].id !== draggableElement.id) {\n      //     const blueBoxCoords = blue_boxes[i].getBoundingClientRect();\n      //     if (current_coords.left < blueBoxCoords.right && current_coords.right > blueBoxCoords.left && current_coords.top < blueBoxCoords.bottom && current_coords.bottom > blueBoxCoords.top) {\n      //       overlappingArea -= Math.max(0, Math.min(current_coords.right, blueBoxCoords.right) - Math.max(current_coords.left, blueBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, blueBoxCoords.bottom) - Math.max(current_coords.top, blueBoxCoords.top));\n      //       break;\n      //     }\n      //   }\n      // }\n\n      // find the overlapping coordinates between the red box and the draggable element\n      // update the coordinates of corresponding box in the boxes array\n      boxes_inside_red[draggableElement.id] = {\n        x1: Math.max(current_coords.left, redBoxCoords.left),\n        y1: Math.max(current_coords.top, redBoxCoords.top),\n        x2: Math.min(current_coords.right, redBoxCoords.right),\n        y2: Math.min(current_coords.bottom, redBoxCoords.bottom)\n      };\n\n      // get the coordinates of all corresponding boxes in the boxes array\n      // const blue_boxes = document.getElementsByClassName(\"draggable\");\n      // const rectArr = Array.from(blue_boxes).map((blueBoxElement) => {\n      //   const { left, right, top, bottom } = blueBoxElement.getBoundingClientRect();\n      //   return [left, top, right, bottom];\n      // });\n\n      var rectArr = Object.values(boxes_inside_red).map(function (box) {\n        return [box.x1, box.y1, box.x2, box.y2];\n      });\n      var coveringRect = function coveringRect(rects) {\n        if (!rects.length) {\n          return null;\n        }\n        var minX = Math.min.apply(Math, _toConsumableArray(rects.map(function (r) {\n          return r[0];\n        })));\n        var minY = Math.min.apply(Math, _toConsumableArray(rects.map(function (r) {\n          return r[1];\n        })));\n        var maxX = Math.max.apply(Math, _toConsumableArray(rects.map(function (r) {\n          return r[2];\n        })));\n        var maxY = Math.max.apply(Math, _toConsumableArray(rects.map(function (r) {\n          return r[3];\n        })));\n        return [minX, minY, maxX, maxY];\n      };\n      var area = function area(_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 4),\n          a = _ref3[0],\n          b = _ref3[1],\n          c = _ref3[2],\n          d = _ref3[3];\n        return (c - a) * (d - b);\n      };\n      var clip = function clip(bb, rects) {\n        if (!rects.length) {\n          return [];\n        }\n        var _rects$ = _slicedToArray(rects[0], 4),\n          x1 = _rects$[0],\n          y1 = _rects$[1],\n          x2 = _rects$[2],\n          y2 = _rects$[3];\n        var rs = rects.slice(1);\n        var _bb = _slicedToArray(bb, 4),\n          a1 = _bb[0],\n          b1 = _bb[1],\n          a2 = _bb[2],\n          b2 = _bb[3];\n        if (a1 === a2 || b1 === b2) {\n          return [];\n        }\n        if (a1 >= x2 || a2 <= x1 || y1 >= b2 || y2 <= b1) {\n          return clip(bb, rs);\n        }\n        return [[Math.max(a1, x1), Math.max(b1, y1), Math.min(a2, x2), Math.min(b2, y2)]].concat(_toConsumableArray(clip(bb, rs)));\n      };\n      var calc = function calc(cr, rects) {\n        if (!rects.length) {\n          return 0;\n        }\n        var rc = rects[0];\n        var rs = rects.slice(1);\n        var _cr = _slicedToArray(cr, 4),\n          x1 = _cr[0],\n          y1 = _cr[1],\n          x2 = _cr[2],\n          y2 = _cr[3];\n        var _rc = _slicedToArray(rc, 4),\n          l1 = _rc[0],\n          m1 = _rc[1],\n          l2 = _rc[2],\n          m2 = _rc[3];\n        var t = [x1, m2, x2, y2];\n        var b = [x1, y1, x2, m1];\n        var l = [x1, m1, l1, m2];\n        var r = [l2, m1, x2, m2];\n        return area(rc) + [t, b, l, r].reduce(function (sum, x) {\n          return sum + calc(x, clip(x, rs));\n        }, 0);\n      };\n      var redBoxRect = [redBoxCoords.left, redBoxCoords.top, redBoxCoords.right, redBoxCoords.bottom];\n      overlappingArea = calc(redBoxRect, rectArr);\n    } else {\n      // if it is not, set the overlapping area to 0\n      // overlappingArea = 0;\n      // reset the coordinates of corresponding box in the boxes array\n      boxes_inside_red[draggableElement.id] = {\n        x1: 0,\n        y1: 0,\n        x2: 0,\n        y2: 0\n      };\n    }\n    console.log(boxes_inside_red);\n    console.log(overlappingArea);\n    callBack(overlappingArea); // call the callback function to update the overlapping area of the draggable element\n    setFinalPosition({\n      x: left - position.x,\n      y: top - position.y\n    }); // update the final position of the draggable element\n  }, [isDragging, dragInfo, ref]);\n  useEffect(function () {\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n    return function () {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [handleMouseMove]);\n  return {\n    position: finalPosition,\n    handleMouseDown: handleMouseDown\n  };\n};\n_s(useDrag, \"Yr7awxu5AALMG3ommDYpy4hAr7M=\");","map":{"version":3,"names":["useCallback","useEffect","useState","boxes_inside_red","x1","y1","x2","y2","overlappingArea","useDrag","_ref","_s","ref","id","callBack","Xs","Ys","initialX","initialY","_useState","_useState2","_slicedToArray","dragInfo","setDragInfo","_useState3","x","y","_useState4","finalPosition","setFinalPosition","_useState5","_useState6","isDragging","setIsDragging","handleMouseUp","evt","preventDefault","handleMouseDown","clientX","clientY","draggableElement","current","_draggableElement$get","getBoundingClientRect","top","left","width","height","startX","startY","handleMouseMove","position","current_coords","redBoxCoords","document","getElementById","right","bottom","Math","max","min","rectArr","Object","values","map","box","coveringRect","rects","length","minX","apply","_toConsumableArray","r","minY","maxX","maxY","area","_ref2","_ref3","a","b","c","d","clip","bb","_rects$","rs","slice","_bb","a1","b1","a2","b2","concat","calc","cr","rc","_cr","_rc","l1","m1","l2","m2","t","l","reduce","sum","redBoxRect","console","log","addEventListener","removeEventListener"],"sources":["/Users/alex/Downloads/ziina-take-home/src/useDrag.js"],"sourcesContent":["import { useCallback, useEffect, useState } from \"react\";\n// create an array of 5 boxes that will be updated to store the coordinates of the overlapping area of each draggable element with the red box\nconst boxes_inside_red = {\n  0: { x1: 0, y1: 0, x2: 0, y2: 0 },\n  1: { x1: 0, y1: 0, x2: 0, y2: 0 },\n  2: { x1: 0, y1: 0, x2: 0, y2: 0 },\n  3: { x1: 0, y1: 0, x2: 0, y2: 0 },\n  4: { x1: 0, y1: 0, x2: 0, y2: 0 }\n};\nlet overlappingArea = 0;\nexport const useDrag = ({ ref, id, callBack }) => {\n  const Xs = [400, 483, 313, 245, 480]; // initial x coordinates of the draggable elements\n  const Ys = [476, 350, 276, 435, 211]; // initial y coordinates of the draggable elements\n  const initialX = Xs[id];\n  const initialY = Ys[id];\n  const [dragInfo, setDragInfo] = useState();\n  const [finalPosition, setFinalPosition] = useState({\n    x: initialX,\n    y: initialY,\n  });\n  const [isDragging, setIsDragging] = useState(false);\n\n  const handleMouseUp = (evt) => {\n    evt.preventDefault();\n\n    setIsDragging(false); // indicates that the user has stopped dragging the element\n  };\n\n  const handleMouseDown = (evt) => {\n    evt.preventDefault();\n\n    const { clientX, clientY } = evt;\n    const { current: draggableElement } = ref; // get the current element that is being dragged\n\n    if (!draggableElement) {\n      return;\n    }\n\n    const {\n      top,\n      left,\n      width,\n      height\n    } = draggableElement.getBoundingClientRect();\n\n    setIsDragging(true); // indicates that the user has started dragging the element\n    setDragInfo({\n      startX: clientX,\n      startY: clientY,\n      top,\n      left,\n      width,\n      height\n    });\n\n  };\n  const handleMouseMove = useCallback(\n    (evt) => {\n      const { current: draggableElement } = ref; // get the current element that is being dragged\n\n      if (!isDragging || !draggableElement) return; // if the user is not dragging the element, do nothing\n\n      evt.preventDefault();\n\n      const { clientX, clientY } = evt; // get the current position of the mouse\n\n      const position = {\n        x: dragInfo.startX - clientX,\n        y: dragInfo.startY - clientY\n      }; // calculate the distance between the current position of the mouse and the initial position of the mouse\n\n      const { top, left, width, height } = dragInfo;\n\n      const current_coords = draggableElement.getBoundingClientRect();\n      //console.log(draggableElement.getBoundingClientRect())\n      const redBoxCoords = document.getElementById('red-box').getBoundingClientRect();\n      // check if the current position of the draggable element overlaps with the red box\n      if (current_coords.left < redBoxCoords.right && current_coords.right > redBoxCoords.left && current_coords.top < redBoxCoords.bottom && current_coords.bottom > redBoxCoords.top) {\n        // // calculate the overlapping area\n        // overlappingArea = Math.max(0, Math.min(current_coords.right, redBoxCoords.right) - Math.max(current_coords.left, redBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, redBoxCoords.bottom) - Math.max(current_coords.top, redBoxCoords.top));\n        // // if the current element overlaps with another draggable element, reduce the overlapping area by the area of the other draggable element, and break the loop when there is overlapping to prevent double counting\n        // const blue_boxes = document.getElementsByClassName(\"draggable\");\n        // for (let i = 0; i < blue_boxes.length; i++) {\n        //   if (blue_boxes[i].id !== draggableElement.id) {\n        //     const blueBoxCoords = blue_boxes[i].getBoundingClientRect();\n        //     if (current_coords.left < blueBoxCoords.right && current_coords.right > blueBoxCoords.left && current_coords.top < blueBoxCoords.bottom && current_coords.bottom > blueBoxCoords.top) {\n        //       overlappingArea -= Math.max(0, Math.min(current_coords.right, blueBoxCoords.right) - Math.max(current_coords.left, blueBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, blueBoxCoords.bottom) - Math.max(current_coords.top, blueBoxCoords.top));\n        //       break;\n        //     }\n        //   }\n        // }\n\n        // find the overlapping coordinates between the red box and the draggable element\n        // update the coordinates of corresponding box in the boxes array\n        boxes_inside_red[draggableElement.id] = { x1: Math.max(current_coords.left, redBoxCoords.left), y1: Math.max(current_coords.top, redBoxCoords.top), x2: Math.min(current_coords.right, redBoxCoords.right), y2: Math.min(current_coords.bottom, redBoxCoords.bottom) };\n\n        // get the coordinates of all corresponding boxes in the boxes array\n        // const blue_boxes = document.getElementsByClassName(\"draggable\");\n        // const rectArr = Array.from(blue_boxes).map((blueBoxElement) => {\n        //   const { left, right, top, bottom } = blueBoxElement.getBoundingClientRect();\n        //   return [left, top, right, bottom];\n        // });\n\n        const rectArr = Object.values(boxes_inside_red).map((box) => {\n          return [box.x1, box.y1, box.x2, box.y2];\n        });\n\n        const coveringRect = (rects) => {\n          if (!rects.length) {\n            return null;\n          }\n\n          const minX = Math.min(...rects.map((r) => r[0]));\n          const minY = Math.min(...rects.map((r) => r[1]));\n          const maxX = Math.max(...rects.map((r) => r[2]));\n          const maxY = Math.max(...rects.map((r) => r[3]));\n\n          return [minX, minY, maxX, maxY];\n        };\n\n        const area = ([a, b, c, d]) => (c - a) * (d - b);\n\n        const clip = (bb, rects) => {\n          if (!rects.length) {\n            return [];\n          }\n\n          const [x1, y1, x2, y2] = rects[0];\n          const rs = rects.slice(1);\n          const [a1, b1, a2, b2] = bb;\n\n          if (a1 === a2 || b1 === b2) {\n            return [];\n          }\n\n          if (a1 >= x2 || a2 <= x1 || y1 >= b2 || y2 <= b1) {\n            return clip(bb, rs);\n          }\n\n          return [\n            [Math.max(a1, x1), Math.max(b1, y1), Math.min(a2, x2), Math.min(b2, y2)],\n            ...clip(bb, rs)\n          ];\n        };\n\n        const calc = (cr, rects) => {\n          if (!rects.length) {\n            return 0;\n          }\n\n          const rc = rects[0];\n          const rs = rects.slice(1);\n          const [x1, y1, x2, y2] = cr;\n          const [l1, m1, l2, m2] = rc;\n          const t = [x1, m2, x2, y2];\n          const b = [x1, y1, x2, m1];\n          const l = [x1, m1, l1, m2];\n          const r = [l2, m1, x2, m2];\n\n          return area(rc) + [t, b, l, r].reduce(\n            (sum, x) => sum + calc(x, clip(x, rs)),\n            0\n          );\n        };\n\n        const redBoxRect = [redBoxCoords.left, redBoxCoords.top, redBoxCoords.right, redBoxCoords.bottom];\n        overlappingArea = calc(redBoxRect, rectArr);\n      } else {\n        // if it is not, set the overlapping area to 0\n        // overlappingArea = 0;\n        // reset the coordinates of corresponding box in the boxes array\n        boxes_inside_red[draggableElement.id] = { x1: 0, y1: 0, x2: 0, y2: 0 };\n      }\n      console.log(boxes_inside_red)\n      console.log(overlappingArea);\n      callBack(overlappingArea); // call the callback function to update the overlapping area of the draggable element\n      setFinalPosition({ x: left - position.x, y: top - position.y }); // update the final position of the draggable element\n    },\n    [isDragging, dragInfo, ref]\n  );\n\n  useEffect(() => {\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [handleMouseMove]);\n\n  return {\n    position: finalPosition,\n    handleMouseDown,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}