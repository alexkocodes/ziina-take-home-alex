{"ast":null,"code":"import _toConsumableArray from \"/Users/alex/Downloads/ziina-take-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/alex/Downloads/ziina-take-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar _s = $RefreshSig$();\nimport { useCallback, useEffect, useState } from \"react\";\n// an array of 5 boxes that will be updated to store the coordinates of the overlapping area of each draggable element with the red box\nvar boxes_inside_red = {\n  0: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0\n  },\n  1: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0\n  },\n  2: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0\n  },\n  3: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0\n  },\n  4: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0\n  }\n};\nvar overlappingArea = 0;\nexport var useDrag = function useDrag(_ref) {\n  _s();\n  var ref = _ref.ref,\n    id = _ref.id,\n    callBack = _ref.callBack;\n  var Xs = [400, 483, 313, 245, 480]; // initial x coordinates of the draggable elements\n  var Ys = [476, 350, 276, 435, 211]; // initial y coordinates of the draggable elements\n  var initialX = Xs[id];\n  var initialY = Ys[id];\n  var _useState = useState(),\n    _useState2 = _slicedToArray(_useState, 2),\n    dragInfo = _useState2[0],\n    setDragInfo = _useState2[1];\n  var _useState3 = useState({\n      x: initialX,\n      y: initialY\n    }),\n    _useState4 = _slicedToArray(_useState3, 2),\n    finalPosition = _useState4[0],\n    setFinalPosition = _useState4[1];\n  var _useState5 = useState(false),\n    _useState6 = _slicedToArray(_useState5, 2),\n    isDragging = _useState6[0],\n    setIsDragging = _useState6[1];\n  var handleMouseUp = function handleMouseUp(evt) {\n    evt.preventDefault();\n    setIsDragging(false); // indicates that the user has stopped dragging the element\n  };\n\n  var handleMouseDown = function handleMouseDown(evt) {\n    evt.preventDefault();\n    var clientX = evt.clientX,\n      clientY = evt.clientY;\n    var draggableElement = ref.current; // get the current element that is being dragged\n\n    if (!draggableElement) {\n      return;\n    }\n    var _draggableElement$get = draggableElement.getBoundingClientRect(),\n      top = _draggableElement$get.top,\n      left = _draggableElement$get.left,\n      width = _draggableElement$get.width,\n      height = _draggableElement$get.height;\n    setIsDragging(true); // indicates that the user has started dragging the element\n    setDragInfo({\n      startX: clientX,\n      startY: clientY,\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    });\n  };\n  var handleMouseMove = useCallback(function (evt) {\n    var draggableElement = ref.current; // get the current element that is being dragged\n\n    if (!isDragging || !draggableElement) return; // if the user is not dragging the element, do nothing\n\n    evt.preventDefault();\n    var clientX = evt.clientX,\n      clientY = evt.clientY; // get the current position of the mouse\n\n    var position = {\n      x: dragInfo.startX - clientX,\n      y: dragInfo.startY - clientY\n    }; // calculate the distance between the current position of the mouse and the initial position of the mouse\n\n    var top = dragInfo.top,\n      left = dragInfo.left,\n      width = dragInfo.width,\n      height = dragInfo.height;\n    var current_coords = draggableElement.getBoundingClientRect(); // get the coordinates of the blue box that is being dragged right now\n    //console.log(draggableElement.getBoundingClientRect())\n    var redBoxCoords = document.getElementById('red-box').getBoundingClientRect(); // get the coordinates of the red box\n    var rectArr = [];\n    // check if the current position of the draggable element overlaps with the red box\n    if (current_coords.left < redBoxCoords.right && current_coords.right > redBoxCoords.left && current_coords.top < redBoxCoords.bottom && current_coords.bottom > redBoxCoords.top) {\n      // store coordinates of the overlapping rectangle area between the red box and the draggable element.\n      boxes_inside_red[draggableElement.id] = {\n        x1: Math.max(current_coords.left, redBoxCoords.left),\n        y1: Math.max(current_coords.top, redBoxCoords.top),\n        x2: Math.min(current_coords.right, redBoxCoords.right),\n        y2: Math.min(current_coords.bottom, redBoxCoords.bottom)\n      };\n\n      // get the coordinates of all corresponding boxes in the boxes array and store them in the rect array\n      rectArr = Object.values(boxes_inside_red).map(function (box) {\n        return [box.x1, box.y1, box.x2, box.y2];\n      });\n    } else {\n      // if the draggable element is not overlapping with the red box\n      // then reset the coordinates of corresponding box in the boxes array\n      boxes_inside_red[draggableElement.id] = {\n        x1: 0,\n        y1: 0,\n        x2: 0,\n        y2: 0\n      };\n      rectArr = Object.values(boxes_inside_red).map(function (box) {\n        return [box.x1, box.y1, box.x2, box.y2];\n      });\n    }\n    var area = function area(_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 4),\n        a = _ref3[0],\n        b = _ref3[1],\n        c = _ref3[2],\n        d = _ref3[3];\n      return (c - a) * (d - b);\n    }; // function to calculate the area of a rectangle\n\n    var clip = function clip(bb, rects) {\n      if (!rects.length) {\n        return [];\n      }\n      var _rects$ = _slicedToArray(rects[0], 4),\n        x1 = _rects$[0],\n        y1 = _rects$[1],\n        x2 = _rects$[2],\n        y2 = _rects$[3];\n      var rs = rects.slice(1);\n      var _bb = _slicedToArray(bb, 4),\n        a1 = _bb[0],\n        b1 = _bb[1],\n        a2 = _bb[2],\n        b2 = _bb[3];\n      if (a1 === a2 || b1 === b2) {\n        return [];\n      }\n      if (a1 >= x2 || a2 <= x1 || y1 >= b2 || y2 <= b1) {\n        return clip(bb, rs);\n      }\n      return [[Math.max(a1, x1), Math.max(b1, y1), Math.min(a2, x2), Math.min(b2, y2)]].concat(_toConsumableArray(clip(bb, rs)));\n    };\n    var calc = function calc(cr, rects) {\n      if (!rects.length) {\n        return 0;\n      }\n      var rc = rects[0];\n      var rs = rects.slice(1);\n      var _cr = _slicedToArray(cr, 4),\n        x1 = _cr[0],\n        y1 = _cr[1],\n        x2 = _cr[2],\n        y2 = _cr[3];\n      var _rc = _slicedToArray(rc, 4),\n        l1 = _rc[0],\n        m1 = _rc[1],\n        l2 = _rc[2],\n        m2 = _rc[3];\n      var t = [x1, m2, x2, y2];\n      var b = [x1, y1, x2, m1];\n      var l = [x1, m1, l1, m2];\n      var r = [l2, m1, x2, m2];\n      return area(rc) + [t, b, l, r].reduce(function (sum, x) {\n        return sum + calc(x, clip(x, rs));\n      },\n      // recursively call the calc function to get the total overlapping area between the red box and the draggable element\n      0);\n    };\n    var redBoxRect = [redBoxCoords.left, redBoxCoords.top, redBoxCoords.right, redBoxCoords.bottom];\n    overlappingArea = calc(redBoxRect, rectArr); // calculate the total overlapping area between the red box and the draggable element\n    callBack(overlappingArea); // call the callBack function to update the total overlapping area of all draggable elements with the red box\n    setFinalPosition({\n      x: left - position.x,\n      y: top - position.y\n    }); // update the final position of the draggable element\n  }, [isDragging, dragInfo, ref]);\n  useEffect(function () {\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n    return function () {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [handleMouseMove]);\n  return {\n    position: finalPosition,\n    handleMouseDown: handleMouseDown\n  };\n};\n_s(useDrag, \"Yr7awxu5AALMG3ommDYpy4hAr7M=\");","map":{"version":3,"names":["useCallback","useEffect","useState","boxes_inside_red","x1","y1","x2","y2","overlappingArea","useDrag","_ref","_s","ref","id","callBack","Xs","Ys","initialX","initialY","_useState","_useState2","_slicedToArray","dragInfo","setDragInfo","_useState3","x","y","_useState4","finalPosition","setFinalPosition","_useState5","_useState6","isDragging","setIsDragging","handleMouseUp","evt","preventDefault","handleMouseDown","clientX","clientY","draggableElement","current","_draggableElement$get","getBoundingClientRect","top","left","width","height","startX","startY","handleMouseMove","position","current_coords","redBoxCoords","document","getElementById","rectArr","right","bottom","Math","max","min","Object","values","map","box","area","_ref2","_ref3","a","b","c","d","clip","bb","rects","length","_rects$","rs","slice","_bb","a1","b1","a2","b2","concat","_toConsumableArray","calc","cr","rc","_cr","_rc","l1","m1","l2","m2","t","l","r","reduce","sum","redBoxRect","addEventListener","removeEventListener"],"sources":["/Users/alex/Downloads/ziina-take-home/src/useDrag.js"],"sourcesContent":["import { useCallback, useEffect, useState } from \"react\";\n// an array of 5 boxes that will be updated to store the coordinates of the overlapping area of each draggable element with the red box\nconst boxes_inside_red = {\n  0: { x1: 0, y1: 0, x2: 0, y2: 0 },\n  1: { x1: 0, y1: 0, x2: 0, y2: 0 },\n  2: { x1: 0, y1: 0, x2: 0, y2: 0 },\n  3: { x1: 0, y1: 0, x2: 0, y2: 0 },\n  4: { x1: 0, y1: 0, x2: 0, y2: 0 }\n};\nlet overlappingArea = 0;\nexport const useDrag = ({ ref, id, callBack }) => {\n  const Xs = [400, 483, 313, 245, 480]; // initial x coordinates of the draggable elements\n  const Ys = [476, 350, 276, 435, 211]; // initial y coordinates of the draggable elements\n  const initialX = Xs[id];\n  const initialY = Ys[id];\n  const [dragInfo, setDragInfo] = useState();\n  const [finalPosition, setFinalPosition] = useState({\n    x: initialX,\n    y: initialY,\n  });\n  const [isDragging, setIsDragging] = useState(false);\n\n  const handleMouseUp = (evt) => {\n    evt.preventDefault();\n\n    setIsDragging(false); // indicates that the user has stopped dragging the element\n  };\n\n  const handleMouseDown = (evt) => {\n    evt.preventDefault();\n\n    const { clientX, clientY } = evt;\n    const { current: draggableElement } = ref; // get the current element that is being dragged\n\n    if (!draggableElement) {\n      return;\n    }\n\n    const {\n      top,\n      left,\n      width,\n      height\n    } = draggableElement.getBoundingClientRect();\n\n    setIsDragging(true); // indicates that the user has started dragging the element\n    setDragInfo({\n      startX: clientX,\n      startY: clientY,\n      top,\n      left,\n      width,\n      height\n    });\n\n  };\n  const handleMouseMove = useCallback(\n    (evt) => {\n      const { current: draggableElement } = ref; // get the current element that is being dragged\n\n      if (!isDragging || !draggableElement) return; // if the user is not dragging the element, do nothing\n\n      evt.preventDefault();\n\n      const { clientX, clientY } = evt; // get the current position of the mouse\n\n      const position = {\n        x: dragInfo.startX - clientX,\n        y: dragInfo.startY - clientY\n      }; // calculate the distance between the current position of the mouse and the initial position of the mouse\n\n      const { top, left, width, height } = dragInfo;\n\n      const current_coords = draggableElement.getBoundingClientRect(); // get the coordinates of the blue box that is being dragged right now\n      //console.log(draggableElement.getBoundingClientRect())\n      const redBoxCoords = document.getElementById('red-box').getBoundingClientRect(); // get the coordinates of the red box\n      let rectArr = [];\n      // check if the current position of the draggable element overlaps with the red box\n      if (current_coords.left < redBoxCoords.right && current_coords.right > redBoxCoords.left && current_coords.top < redBoxCoords.bottom && current_coords.bottom > redBoxCoords.top) {\n        // store coordinates of the overlapping rectangle area between the red box and the draggable element.\n        boxes_inside_red[draggableElement.id] = { x1: Math.max(current_coords.left, redBoxCoords.left), y1: Math.max(current_coords.top, redBoxCoords.top), x2: Math.min(current_coords.right, redBoxCoords.right), y2: Math.min(current_coords.bottom, redBoxCoords.bottom) };\n\n        // get the coordinates of all corresponding boxes in the boxes array and store them in the rect array\n        rectArr = Object.values(boxes_inside_red).map((box) => {\n          return [box.x1, box.y1, box.x2, box.y2];\n        });\n      } else { // if the draggable element is not overlapping with the red box\n        // then reset the coordinates of corresponding box in the boxes array\n        boxes_inside_red[draggableElement.id] = { x1: 0, y1: 0, x2: 0, y2: 0 };\n        rectArr = Object.values(boxes_inside_red).map((box) => {\n          return [box.x1, box.y1, box.x2, box.y2];\n        });\n      }\n      const area = ([a, b, c, d]) => (c - a) * (d - b); // function to calculate the area of a rectangle\n\n      const clip = (bb, rects) => {\n        if (!rects.length) {\n          return [];\n        }\n\n        const [x1, y1, x2, y2] = rects[0];\n        const rs = rects.slice(1);\n        const [a1, b1, a2, b2] = bb;\n\n        if (a1 === a2 || b1 === b2) {\n          return [];\n        }\n\n        if (a1 >= x2 || a2 <= x1 || y1 >= b2 || y2 <= b1) {\n          return clip(bb, rs);\n        }\n\n        return [\n          [Math.max(a1, x1), Math.max(b1, y1), Math.min(a2, x2), Math.min(b2, y2)],\n          ...clip(bb, rs) // recursively call the clip function to get the coordinates of the overlapping area between the red box (bounding box) and the blue boxes that are overlapping with it\n        ];\n      };\n\n      const calc = (cr, rects) => {\n        if (!rects.length) {\n          return 0;\n        }\n\n        const rc = rects[0];\n        const rs = rects.slice(1);\n        const [x1, y1, x2, y2] = cr;\n        const [l1, m1, l2, m2] = rc;\n        const t = [x1, m2, x2, y2];\n        const b = [x1, y1, x2, m1];\n        const l = [x1, m1, l1, m2];\n        const r = [l2, m1, x2, m2];\n\n        return area(rc) + [t, b, l, r].reduce(\n          (sum, x) => sum + calc(x, clip(x, rs)), // recursively call the calc function to get the total overlapping area between the red box and the draggable element\n          0\n        );\n      };\n\n      const redBoxRect = [redBoxCoords.left, redBoxCoords.top, redBoxCoords.right, redBoxCoords.bottom];\n      overlappingArea = calc(redBoxRect, rectArr); // calculate the total overlapping area between the red box and the draggable element\n      callBack(overlappingArea); // call the callBack function to update the total overlapping area of all draggable elements with the red box\n      setFinalPosition({ x: left - position.x, y: top - position.y }); // update the final position of the draggable element\n    },\n    [isDragging, dragInfo, ref]\n  );\n\n  useEffect(() => {\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [handleMouseMove]);\n\n  return {\n    position: finalPosition,\n    handleMouseDown,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}