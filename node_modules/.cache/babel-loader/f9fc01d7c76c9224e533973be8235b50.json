{"ast":null,"code":"import _toConsumableArray from \"/Users/alex/Downloads/ziina-take-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/alex/Downloads/ziina-take-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar _s = $RefreshSig$();\nimport { useCallback, useEffect, useState } from \"react\";\nexport var useDrag = function useDrag(_ref) {\n  _s();\n  var ref = _ref.ref,\n    id = _ref.id,\n    callBack = _ref.callBack;\n  var Xs = [400, 483, 313, 245, 480]; // initial x coordinates of the draggable elements\n  var Ys = [476, 350, 276, 435, 211]; // initial y coordinates of the draggable elements\n  var initialX = Xs[id];\n  var initialY = Ys[id];\n  var _useState = useState(),\n    _useState2 = _slicedToArray(_useState, 2),\n    dragInfo = _useState2[0],\n    setDragInfo = _useState2[1];\n  var _useState3 = useState({\n      x: initialX,\n      y: initialY\n    }),\n    _useState4 = _slicedToArray(_useState3, 2),\n    finalPosition = _useState4[0],\n    setFinalPosition = _useState4[1];\n  var _useState5 = useState(false),\n    _useState6 = _slicedToArray(_useState5, 2),\n    isDragging = _useState6[0],\n    setIsDragging = _useState6[1];\n  var overlappingArea = 0;\n  var handleMouseUp = function handleMouseUp(evt) {\n    evt.preventDefault();\n    setIsDragging(false); // indicates that the user has stopped dragging the element\n  };\n\n  var handleMouseDown = function handleMouseDown(evt) {\n    evt.preventDefault();\n    var clientX = evt.clientX,\n      clientY = evt.clientY;\n    var draggableElement = ref.current; // get the current element that is being dragged\n\n    if (!draggableElement) {\n      return;\n    }\n    var _draggableElement$get = draggableElement.getBoundingClientRect(),\n      top = _draggableElement$get.top,\n      left = _draggableElement$get.left,\n      width = _draggableElement$get.width,\n      height = _draggableElement$get.height;\n    setIsDragging(true); // indicates that the user has started dragging the element\n    setDragInfo({\n      startX: clientX,\n      startY: clientY,\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    });\n  };\n  var handleMouseMove = useCallback(function (evt) {\n    var draggableElement = ref.current; // get the current element that is being dragged\n\n    if (!isDragging || !draggableElement) return; // if the user is not dragging the element, do nothing\n\n    evt.preventDefault();\n    var clientX = evt.clientX,\n      clientY = evt.clientY; // get the current position of the mouse\n\n    var position = {\n      x: dragInfo.startX - clientX,\n      y: dragInfo.startY - clientY\n    }; // calculate the distance between the current position of the mouse and the initial position of the mouse\n\n    var top = dragInfo.top,\n      left = dragInfo.left,\n      width = dragInfo.width,\n      height = dragInfo.height;\n    var current_coords = draggableElement.getBoundingClientRect();\n    //console.log(draggableElement.getBoundingClientRect())\n    var redBoxCoords = document.getElementById('red-box').getBoundingClientRect();\n    // check if the current position of the draggable element overlaps with the red box\n    if (current_coords.left < redBoxCoords.right && current_coords.right > redBoxCoords.left && current_coords.top < redBoxCoords.bottom && current_coords.bottom > redBoxCoords.top) {\n      // // calculate the overlapping area\n      // overlappingArea = Math.max(0, Math.min(current_coords.right, redBoxCoords.right) - Math.max(current_coords.left, redBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, redBoxCoords.bottom) - Math.max(current_coords.top, redBoxCoords.top));\n      // // if the current element overlaps with another draggable element, reduce the overlapping area by the area of the other draggable element, and break the loop when there is overlapping to prevent double counting\n      // const blue_boxes = document.getElementsByClassName(\"draggable\");\n      // for (let i = 0; i < blue_boxes.length; i++) {\n      //   if (blue_boxes[i].id !== draggableElement.id) {\n      //     const blueBoxCoords = blue_boxes[i].getBoundingClientRect();\n      //     if (current_coords.left < blueBoxCoords.right && current_coords.right > blueBoxCoords.left && current_coords.top < blueBoxCoords.bottom && current_coords.bottom > blueBoxCoords.top) {\n      //       overlappingArea -= Math.max(0, Math.min(current_coords.right, blueBoxCoords.right) - Math.max(current_coords.left, blueBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, blueBoxCoords.bottom) - Math.max(current_coords.top, blueBoxCoords.top));\n      //       break;\n      //     }\n      //   }\n      // }\n\n      var rectArr = [];\n      var blue_boxes = document.getElementsByClassName(\"draggable\");\n      for (var i = 0; i < blue_boxes.length; i++) {\n        var blueBoxCoords = blue_boxes[i].getBoundingClientRect();\n        rectArr.push([blueBoxCoords.left, blueBoxCoords.top, blueBoxCoords.right, blueBoxCoords.bottom]);\n      }\n      var coveringRect = function coveringRect(rects) {\n        if (!rects.length) {\n          return null;\n        }\n        var minX = Math.min.apply(Math, _toConsumableArray(rects.map(function (r) {\n          return r[0];\n        })));\n        var minY = Math.min.apply(Math, _toConsumableArray(rects.map(function (r) {\n          return r[1];\n        })));\n        var maxX = Math.max.apply(Math, _toConsumableArray(rects.map(function (r) {\n          return r[2];\n        })));\n        var maxY = Math.max.apply(Math, _toConsumableArray(rects.map(function (r) {\n          return r[3];\n        })));\n        return [minX, minY, maxX, maxY];\n      };\n      var area = function area(_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 4),\n          a = _ref3[0],\n          b = _ref3[1],\n          c = _ref3[2],\n          d = _ref3[3];\n        return (c - a) * (d - b);\n      };\n      var clip = function clip(bb, rects) {\n        if (!rects.length) {\n          return [];\n        }\n        var _rects$ = _slicedToArray(rects[0], 4),\n          x1 = _rects$[0],\n          y1 = _rects$[1],\n          x2 = _rects$[2],\n          y2 = _rects$[3];\n        var rs = rects.slice(1);\n        var _bb = _slicedToArray(bb, 4),\n          a1 = _bb[0],\n          b1 = _bb[1],\n          a2 = _bb[2],\n          b2 = _bb[3];\n        if (a1 === a2 || b1 === b2) {\n          return [];\n        }\n        if (a1 >= x2 || a2 <= x1 || y1 >= b2 || y2 <= b1) {\n          return clip(bb, rs);\n        }\n        return [[Math.max(a1, x1), Math.max(b1, y1), Math.min(a2, x2), Math.min(b2, y2)]].concat(_toConsumableArray(clip(bb, rs)));\n      };\n      var calc = function calc(cr, rects) {\n        if (!rects.length) {\n          return 0;\n        }\n        var rc = rects[0];\n        var rs = rects.slice(1);\n        var _cr = _slicedToArray(cr, 4),\n          x1 = _cr[0],\n          y1 = _cr[1],\n          x2 = _cr[2],\n          y2 = _cr[3];\n        var _rc = _slicedToArray(rc, 4),\n          l1 = _rc[0],\n          m1 = _rc[1],\n          l2 = _rc[2],\n          m2 = _rc[3];\n        var t = [x1, m2, x2, y2];\n        var b = [x1, y1, x2, m1];\n        var l = [x1, m1, l1, m2];\n        var r = [l2, m1, x2, m2];\n        return area(rc) + [t, b, l, r].reduce(function (sum, x) {\n          return sum + calc(x, clip(x, rs));\n        }, 0);\n      };\n      var coveringRectangle = coveringRect(rectArr);\n      var totalArea = calc(coveringRectangle, rectArr);\n      setVisibleArea(totalArea);\n    } else {\n      // if it is not, set the overlapping area to 0\n      overlappingArea = 0;\n    }\n    callBack(overlappingArea); // call the callback function to update the overlapping area of the draggable element\n    setFinalPosition({\n      x: left - position.x,\n      y: top - position.y\n    }); // update the final position of the draggable element\n  }, [isDragging, dragInfo, ref]);\n  useEffect(function () {\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n    return function () {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [handleMouseMove]);\n  return {\n    position: finalPosition,\n    handleMouseDown: handleMouseDown\n  };\n};\n_s(useDrag, \"Yr7awxu5AALMG3ommDYpy4hAr7M=\");","map":{"version":3,"names":["useCallback","useEffect","useState","useDrag","_ref","_s","ref","id","callBack","Xs","Ys","initialX","initialY","_useState","_useState2","_slicedToArray","dragInfo","setDragInfo","_useState3","x","y","_useState4","finalPosition","setFinalPosition","_useState5","_useState6","isDragging","setIsDragging","overlappingArea","handleMouseUp","evt","preventDefault","handleMouseDown","clientX","clientY","draggableElement","current","_draggableElement$get","getBoundingClientRect","top","left","width","height","startX","startY","handleMouseMove","position","current_coords","redBoxCoords","document","getElementById","right","bottom","rectArr","blue_boxes","getElementsByClassName","i","length","blueBoxCoords","push","coveringRect","rects","minX","Math","min","apply","_toConsumableArray","map","r","minY","maxX","max","maxY","area","_ref2","_ref3","a","b","c","d","clip","bb","_rects$","x1","y1","x2","y2","rs","slice","_bb","a1","b1","a2","b2","concat","calc","cr","rc","_cr","_rc","l1","m1","l2","m2","t","l","reduce","sum","coveringRectangle","totalArea","setVisibleArea","addEventListener","removeEventListener"],"sources":["/Users/alex/Downloads/ziina-take-home/src/useDrag.js"],"sourcesContent":["import { useCallback, useEffect, useState } from \"react\";\n\nexport const useDrag = ({ ref, id, callBack }) => {\n  const Xs = [400, 483, 313, 245, 480]; // initial x coordinates of the draggable elements\n  const Ys = [476, 350, 276, 435, 211]; // initial y coordinates of the draggable elements\n  const initialX = Xs[id];\n  const initialY = Ys[id];\n  const [dragInfo, setDragInfo] = useState();\n  const [finalPosition, setFinalPosition] = useState({\n    x: initialX,\n    y: initialY,\n  });\n  const [isDragging, setIsDragging] = useState(false);\n  let overlappingArea = 0;\n\n  const handleMouseUp = (evt) => {\n    evt.preventDefault();\n\n    setIsDragging(false); // indicates that the user has stopped dragging the element\n  };\n\n  const handleMouseDown = (evt) => {\n    evt.preventDefault();\n\n    const { clientX, clientY } = evt;\n    const { current: draggableElement } = ref; // get the current element that is being dragged\n\n    if (!draggableElement) {\n      return;\n    }\n\n    const {\n      top,\n      left,\n      width,\n      height\n    } = draggableElement.getBoundingClientRect();\n\n    setIsDragging(true); // indicates that the user has started dragging the element\n    setDragInfo({\n      startX: clientX,\n      startY: clientY,\n      top,\n      left,\n      width,\n      height\n    });\n\n  };\n\n  const handleMouseMove = useCallback(\n    (evt) => {\n      const { current: draggableElement } = ref; // get the current element that is being dragged\n\n      if (!isDragging || !draggableElement) return; // if the user is not dragging the element, do nothing\n\n      evt.preventDefault();\n\n      const { clientX, clientY } = evt; // get the current position of the mouse\n\n      const position = {\n        x: dragInfo.startX - clientX,\n        y: dragInfo.startY - clientY\n      }; // calculate the distance between the current position of the mouse and the initial position of the mouse\n\n      const { top, left, width, height } = dragInfo;\n\n      const current_coords = draggableElement.getBoundingClientRect();\n      //console.log(draggableElement.getBoundingClientRect())\n      const redBoxCoords = document.getElementById('red-box').getBoundingClientRect();\n      // check if the current position of the draggable element overlaps with the red box\n      if (current_coords.left < redBoxCoords.right && current_coords.right > redBoxCoords.left && current_coords.top < redBoxCoords.bottom && current_coords.bottom > redBoxCoords.top) {\n        // // calculate the overlapping area\n        // overlappingArea = Math.max(0, Math.min(current_coords.right, redBoxCoords.right) - Math.max(current_coords.left, redBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, redBoxCoords.bottom) - Math.max(current_coords.top, redBoxCoords.top));\n        // // if the current element overlaps with another draggable element, reduce the overlapping area by the area of the other draggable element, and break the loop when there is overlapping to prevent double counting\n        // const blue_boxes = document.getElementsByClassName(\"draggable\");\n        // for (let i = 0; i < blue_boxes.length; i++) {\n        //   if (blue_boxes[i].id !== draggableElement.id) {\n        //     const blueBoxCoords = blue_boxes[i].getBoundingClientRect();\n        //     if (current_coords.left < blueBoxCoords.right && current_coords.right > blueBoxCoords.left && current_coords.top < blueBoxCoords.bottom && current_coords.bottom > blueBoxCoords.top) {\n        //       overlappingArea -= Math.max(0, Math.min(current_coords.right, blueBoxCoords.right) - Math.max(current_coords.left, blueBoxCoords.left)) * Math.max(0, Math.min(current_coords.bottom, blueBoxCoords.bottom) - Math.max(current_coords.top, blueBoxCoords.top));\n        //       break;\n        //     }\n        //   }\n        // }\n\n        const rectArr = [];\n        const blue_boxes = document.getElementsByClassName(\"draggable\");\n        for (let i = 0; i < blue_boxes.length; i++) {\n          const blueBoxCoords = blue_boxes[i].getBoundingClientRect();\n          rectArr.push([blueBoxCoords.left, blueBoxCoords.top, blueBoxCoords.right, blueBoxCoords.bottom]);\n        }\n\n\n        const coveringRect = (rects) => {\n          if (!rects.length) {\n            return null;\n          }\n\n          const minX = Math.min(...rects.map((r) => r[0]));\n          const minY = Math.min(...rects.map((r) => r[1]));\n          const maxX = Math.max(...rects.map((r) => r[2]));\n          const maxY = Math.max(...rects.map((r) => r[3]));\n\n          return [minX, minY, maxX, maxY];\n        };\n\n        const area = ([a, b, c, d]) => (c - a) * (d - b);\n\n        const clip = (bb, rects) => {\n          if (!rects.length) {\n            return [];\n          }\n\n          const [x1, y1, x2, y2] = rects[0];\n          const rs = rects.slice(1);\n          const [a1, b1, a2, b2] = bb;\n\n          if (a1 === a2 || b1 === b2) {\n            return [];\n          }\n\n          if (a1 >= x2 || a2 <= x1 || y1 >= b2 || y2 <= b1) {\n            return clip(bb, rs);\n          }\n\n          return [\n            [Math.max(a1, x1), Math.max(b1, y1), Math.min(a2, x2), Math.min(b2, y2)],\n            ...clip(bb, rs)\n          ];\n        };\n\n        const calc = (cr, rects) => {\n          if (!rects.length) {\n            return 0;\n          }\n\n          const rc = rects[0];\n          const rs = rects.slice(1);\n          const [x1, y1, x2, y2] = cr;\n          const [l1, m1, l2, m2] = rc;\n          const t = [x1, m2, x2, y2];\n          const b = [x1, y1, x2, m1];\n          const l = [x1, m1, l1, m2];\n          const r = [l2, m1, x2, m2];\n\n          return area(rc) + [t, b, l, r].reduce(\n            (sum, x) => sum + calc(x, clip(x, rs)),\n            0\n          );\n        };\n\n        const coveringRectangle = coveringRect(rectArr);\n        const totalArea = calc(coveringRectangle, rectArr);\n        setVisibleArea(totalArea);\n      } else {\n        // if it is not, set the overlapping area to 0\n        overlappingArea = 0;\n      }\n      callBack(overlappingArea); // call the callback function to update the overlapping area of the draggable element\n      setFinalPosition({ x: left - position.x, y: top - position.y }); // update the final position of the draggable element\n    },\n    [isDragging, dragInfo, ref]\n  );\n\n  useEffect(() => {\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [handleMouseMove]);\n\n  return {\n    position: finalPosition,\n    handleMouseDown,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}